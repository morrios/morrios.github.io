### 问题

最近在公司项目中遇到身份证号码校验的问题，按照之前经验都是直接撸袖子上正则匹配，简单粗暴出成果。

```
1、15位或18位，如果是15位，必需全是数字。
2、如果是18位，最后一位可以是数字或字母Xx，其余必需是数字。

5位数身份证验证正则表达式：
isIDCard1=/^[1-9]\d{7}((0\d)|(1[0-2]))(([0|1|2]\d)|3[0-1])\d{3}$/; 

18位数身份证验证正则表达式 ：
isIDCard2=/^[1-9]\d{5}[1-9]\d{3}((0\d)|(1[0-2]))(([0|1|2]\d)|3[0-1])\d{3}([0-9]|X)$/;

15/18位数身份证验证正则表达式 ：
isIDCard3=/^(\d{15}$|^\d{18}$|^\d{17}(\d|X|x))$/

```

但是这样，会有问题就是：**不精准**，简单改变其中的几个值，仍然可以通过，可是这个身份证号其实可能是不存在的。

### 要求

由于是金融类项目，对身份证要求比较精确。现在老板不满意了，要求必须是正确的身份证号。

### 详细

于是去查询了相关资料

这里我们只考虑二代身份证，即**18**位（15位的估计也没人用了）。

新的二代公民身份号码是特征组合码，由十七位数字本体码和一位校验码组成。排列顺序从左至右依次为：六位数字地址码，八位数字出生日期码，三位数字顺序码和一位校验码。

其含义如下：
 
  1. 地址码：表示编码对象常住户口所在县(市、旗、区)的行政区划代码，按GB/T2260的规定执行。
  2. 出生日期码：表示编码对象出生的年、月、日，按GB/T7408的规定执行，年、月、日分别用4位、2位、2位数字表示，之间不用分隔符。
  3. 顺序码：表示在同一地址码所标识的区域范围内，对同年、同月、同日出生的人编定的顺序号，顺序码的奇数分配给男性，偶数分配给女性。
  4. 校验码：这个是根据前17位，加权求和，对11求余，在对应得到相应的值。

有了这个就简单多了，只要先用正则过滤一遍，在用校验码算法验证，基本就可以了。而且，有需要的话，甚至可以根据这个逆推出用户的出生日期，性别，地址。

### 校验码计算方式
校验的计算方式：

  1. 对前17位数字本体码加权求和
 
  ```
  公式为：S = Sum(Ai * Wi), i = 0, ... , 16。
  其中Ai表示第i位置上的身份证号码数字值，Wi表示第i位置上的加权因子
  其各位对应的值依次为： 7 9 10 5 8 4 2 1 6 3 7 9 10 5 8 4 2
 ```
  2. 以11对计算结果取模
  Y = sum % 11

  3. 根据模的值得到对应的校验码
  对应关系为：
  
  ```
   Y值:	 0 1 2 3 4 5 6 7 8 9 10
   校验码: 1 0 X 9 8 7 6 5 4 3 2
  ```
  
### 代码
 由于是为了做项目，目前只有OC版本的。后期看情况有时间在加上swift的和C语言版本。
 
 ```
- (BOOL)isValidWithIdentityNum:(NSString *)IdentityNum{
    //先正则匹配
   //......
   
   
    //计算最后一位余数
    NSArray *arrExp = [NSArray arrayWithObjects:@"7", @"9", @"10", @"5", @"8", @"4", @"2", @"1", @"6", @"3", @"7", @"9", @"10", @"5", @"8", @"4", @"2", nil];
    NSArray *arrVaild = [NSArray arrayWithObjects:@"1", @"0", @"X", @"9", @"8", @"7", @"6", @"5", @"4", @"3", @"2", nil];
    
    long sum = 0;
    for (int i = 0; i < (IdentityNum.length -1); i++) {
        NSString * str = [IdentityNum substringWithRange:NSMakeRange(i, 1)];
        sum += [str intValue] * [arrExp[i] intValue];
    }
    
    int idx = (sum % 11);
    if ([arrVaild[idx] isEqualToString:[IdentityNum substringWithRange:NSMakeRange(IdentityNum.length - 1, 1)]]) {
        return YES;
    }else{
        return NO;
    }
    
    
    
    return YES;
}
 ```



